<!DOCTYPE html>
<meta charset="utf-8">
<style>

</style>

<svg width="700" height="700" id="container"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<!--<script src='js/graph.js'></script>-->
<script>
var svg = d3.select('#container'),
    width = +svg.attr("width"),
    height = +svg.attr("height");

var margin = {top: 15, right: 50, bottom: 0, left: 50};

var xScale = d3.scaleBand().rangeRound([0, width-margin.right]).padding(0.1);

var focus = svg.append('g')
               .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

// function to convert input data from strings to floats
var dataConverter = function(d) {
  return {
    "Cancer Type": d['cancer_type'],
    "5 years": +d['5 year'],
    "10 years": +d['10 year'],
    "15 years": +d['15 year'],
    "20 years": +d['20 year']
  }
}



function MiniScaler(d) {
  var maxSpread = getWidestSpread(d);
  this.maxDomain = maxSpread[1]-maxSpread[0];
  this.maxRange = height/data.length;
  this.scale = function (value) {
    return value / this.maxDomain * this.maxRange;
  }
}
var testData = [
  {date: 20, value: 93.24},
  {date: 40, value: 95.35},
  {date: 60, value: 98.84},
  {date: 80, value: 99.92},
  {date: 100, value: 99.80},
  {date: 120, value: 99.47}
];
var data;
var manualYScale;
var scaler;
d3.csv('cancer_survival.csv', dataConverter, function(input_data) {
  data = input_data;
  var headers = d3.keys(data[0]);
  xScale.domain(headers);
  focus.selectAll('.table-header')
       .data(headers)
       .enter()
       .append('text')
       .attr('text-anchor', 'middle')
       .attr('class', 'table-header')
       .attr('x', function(d) { return xScale(d)})
       .text(function(d) { return d});

  var start = 30;
  var padding = 15;
  scaler = new MiniScaler(data)
  var rows = focus.selectAll('.table-row')
                  .data(data)
                  .enter()
                  .append('g')
                  .attr('class', 'table-row')
                  .attr('transform', function(d) {
                    var spread = getSpread(d);
                    var transform = 'translate(0, ' + start + ')';
                    var y = scaler.scale(spread[1]-spread[0]);
                    start = start + padding + y;
                    return transform;
                  })
  var textLabels = rows.selectAll('.datum')
                       .data(function(d) {
                         var entries = d3.entries(d);
                         entries.forEach(function(entry) {
                           entry['max'] = getMaxValue(d);
                         })
                         return entries;
                       })
                       .enter().append('text')
                       .attr('class', 'datum')
                       .attr('transform', function(d) {
                         if (d.key == 'Cancer Type') {
                           return 'translate(' + (xScale(d.key) - xScale.bandwidth()/2) + ',0)'
                         }
                         var y = d.max - d.value;
                         return 'translate('+ xScale(d.key)+',' + (scaler.scale(y)) +')';
                       })
                       .text(function(d) { return d.value});

      var lineData = [];
      data.forEach(function(d) {
        var entries = d3.entries(d);
        entries.forEach(function(entry) {
          entry['max'] = getMaxValue(d);
        })
        entries.shift();
        lineData.push(entries);
      })

      rows.append('path')
          .datum(function(d, i) {
            return lineData[i]
          })
          .attr('class', 'link')
          .attr('d', line)
          .attr('stroke', 'blue')
          .attr('stroke-width', 2)
          .attr('fill','none');

})

var line = d3.line()
             .x(function(d) {
               return xScale(d.key)+10;
             })
             .y(function(d) {
               return scaler.scale(d.max - d.value)-5;
             })
             .curve(d3.curveLinear);

function getMaxValue(d) {
  var keys = Object.keys(d);
  // remove the header
  keys.shift();
  var max = -100000000000;
  keys.forEach(function(key) {
    if (d[key] > max) {
      max = d[key];
    }
  })
  return max;
}

function getSpread(d) {
  var keys = Object.keys(d);
  var min = 10000000000;
  var max = -100000000000;
  keys.forEach(function(key) {
    if (d[key] > max) {
      max = d[key];
    }
    if (d[key] < min) {
      min = d[key];
    }
  })
  return [min, max];
}

function getWidestSpread(d) {
  var keys = Object.keys(d[0]);
  // remove the header
  keys.shift();
  var widestSpread = [0,0];
  d.forEach(function(item) {
    var itemSpread = getSpread(item);
    if (itemSpread[1] - itemSpread[0] > (widestSpread[1] - widestSpread[0])) {
      widestSpread = itemSpread;
    }
  })
  return widestSpread;
}

</script>
